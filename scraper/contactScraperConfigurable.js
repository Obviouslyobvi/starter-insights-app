/**
 * Configurable Contact Scraper for PFAC Pro Directory
 *
 * This script uses the configuration from scraperConfig.json (generated by selectorHelper.js)
 * to scrape contact information and export to CSV.
 *
 * Usage:
 *   1. First run: node scraper/selectorHelper.js (to generate config)
 *   2. Then run: node scraper/contactScraperConfigurable.js
 */

const { chromium } = require('playwright');
const fs = require('fs');
const path = require('path');

// Load configuration
const CONFIG_FILE = path.join(__dirname, 'scraperConfig.json');
let SELECTORS = {};

try {
  const configData = fs.readFileSync(CONFIG_FILE, 'utf8');
  const config = JSON.parse(configData);
  SELECTORS = config.selectors;
  console.log('‚úì Loaded configuration from scraperConfig.json');
} catch (e) {
  console.log('‚ö† No configuration file found. Using default selectors.');
  console.log('  Run "node scraper/selectorHelper.js" first to configure selectors.\n');

  // Default selectors - adjust these based on common patterns
  SELECTORS = {
    contactRow: 'table tbody tr',
    nameLink: 'td a',
    address: 'td:nth-child(2)',
    cityStateZip: 'td:nth-child(3)',
    phone: 'td:nth-child(4)',
    email: 'a[href^="mailto:"]',
    nextPage: 'a:has-text("Next")'
  };
}

// Runtime configuration
const CONFIG = {
  baseUrl: 'https://pfac-pro.site-ym.com/search/newsearch.asp',
  outputFile: 'contacts_export.csv',
  headless: false,
  slowMo: 50,
  timeout: 30000,
  maxPages: 35,
  delayBetweenContacts: 300,
  delayBetweenPages: 800,
};

// CSV headers
const CSV_HEADERS = [
  'First Name',
  'Middle Initial',
  'Last Name',
  'Address1',
  'Address2',
  'City',
  'State',
  'Zip',
  'Phone',
  'Email'
];

let allContacts = [];
let processedCount = 0;

/**
 * Parse name into components
 */
function parseName(fullName) {
  if (!fullName) return { firstName: '', middleInitial: '', lastName: '' };

  // Clean up the name
  let name = fullName.trim()
    .replace(/\s+/g, ' ')
    .replace(/,.*$/, ''); // Remove anything after comma (like titles)

  const parts = name.split(' ');

  if (parts.length === 1) {
    return { firstName: parts[0], middleInitial: '', lastName: '' };
  } else if (parts.length === 2) {
    return { firstName: parts[0], middleInitial: '', lastName: parts[1] };
  } else {
    // Check for middle initial
    const second = parts[1];
    if (second.length === 1 || (second.length === 2 && second.endsWith('.'))) {
      return {
        firstName: parts[0],
        middleInitial: second.replace('.', ''),
        lastName: parts.slice(2).join(' ')
      };
    }
    return {
      firstName: parts[0],
      middleInitial: '',
      lastName: parts.slice(1).join(' ')
    };
  }
}

/**
 * Parse city, state, zip from text
 */
function parseCityStateZip(text) {
  if (!text) return { city: '', state: '', zip: '' };

  // Pattern: City, ST 12345 or City ST 12345
  const match = text.match(/^(.+?)[,\s]+([A-Z]{2})\s+(\d{5}(?:-\d{4})?)$/i);
  if (match) {
    return {
      city: match[1].trim(),
      state: match[2].toUpperCase(),
      zip: match[3]
    };
  }

  return { city: text.trim(), state: '', zip: '' };
}

/**
 * Parse address into address1 and address2
 */
function parseAddress(text) {
  if (!text) return { address1: '', address2: '' };

  const lines = text.split(/[\n\r]+/).map(l => l.trim()).filter(l => l);

  if (lines.length === 0) {
    return { address1: '', address2: '' };
  } else if (lines.length === 1) {
    return { address1: lines[0], address2: '' };
  } else {
    return { address1: lines[0], address2: lines.slice(1).join(', ') };
  }
}

/**
 * Clean phone number
 */
function cleanPhone(phone) {
  if (!phone) return '';
  // Extract phone pattern
  const match = phone.match(/[\d().\s-]{10,}/);
  return match ? match[0].trim() : phone.trim();
}

/**
 * Extract email from text or mailto link
 */
function extractEmail(text) {
  if (!text) return '';

  // If it's a mailto link
  if (text.startsWith('mailto:')) {
    return text.replace('mailto:', '').split('?')[0].toLowerCase();
  }

  // Extract email pattern
  const match = text.match(/[\w.-]+@[\w.-]+\.\w+/i);
  return match ? match[0].toLowerCase() : '';
}

/**
 * Escape CSV field
 */
function escapeCSV(field) {
  if (field === null || field === undefined) return '';
  const str = String(field);
  if (str.includes(',') || str.includes('"') || str.includes('\n')) {
    return `"${str.replace(/"/g, '""')}"`;
  }
  return str;
}

/**
 * Save contacts to CSV
 */
function saveToCSV(contacts, filename) {
  const header = CSV_HEADERS.map(escapeCSV).join(',');
  const rows = contacts.map(c => [
    c.firstName, c.middleInitial, c.lastName,
    c.address1, c.address2, c.city, c.state, c.zip,
    c.phone, c.email
  ].map(escapeCSV).join(','));

  const csv = [header, ...rows].join('\n');
  const outputPath = path.join(__dirname, '..', filename);
  fs.writeFileSync(outputPath, csv, 'utf8');
  return outputPath;
}

/**
 * Wait for user login
 */
async function waitForResults(page) {
  console.log('\n‚è≥ Waiting for search results...');
  console.log('   If login is required, please log in now.');
  console.log('   The script will continue when results appear.\n');

  try {
    await page.waitForSelector(SELECTORS.contactRow, { timeout: 300000 });
    console.log('‚úì Search results detected!\n');
    return true;
  } catch (e) {
    console.log('‚ö† Timeout waiting for results. Proceeding anyway...\n');
    return false;
  }
}

/**
 * Get email from detail page
 */
async function getEmailFromDetailPage(page, url) {
  try {
    await page.goto(url, { waitUntil: 'domcontentloaded', timeout: CONFIG.timeout });
    await page.waitForTimeout(300);

    // Try the configured selector first
    let email = '';

    const emailElement = await page.$(SELECTORS.email);
    if (emailElement) {
      const href = await emailElement.getAttribute('href');
      const text = await emailElement.innerText();
      email = extractEmail(href || text);
    }

    // Fallback: search for any email on page
    if (!email) {
      email = await page.evaluate(() => {
        // Check mailto links
        const mailto = document.querySelector('a[href^="mailto:"]');
        if (mailto) return mailto.href;

        // Search page text
        const text = document.body.innerText;
        const match = text.match(/[\w.-]+@[\w.-]+\.\w+/);
        return match ? match[0] : '';
      });
      email = extractEmail(email);
    }

    return email;
  } catch (e) {
    console.log(`      ‚ö† Error getting email: ${e.message}`);
    return '';
  }
}

/**
 * Extract contacts from current page
 */
async function extractContactsFromPage(page) {
  const contacts = [];

  const rows = await page.$$(SELECTORS.contactRow);
  console.log(`   Found ${rows.length} rows`);

  for (let i = 0; i < rows.length; i++) {
    const row = rows[i];

    try {
      // Check if this is a header row
      const isHeader = await row.$('th');
      if (isHeader) continue;

      // Get name link
      const nameLink = await row.$(SELECTORS.nameLink);
      if (!nameLink) continue;

      const name = await nameLink.innerText();
      const href = await nameLink.getAttribute('href');

      // Skip if no valid name
      if (!name || name.trim().length === 0) continue;

      // Get other fields
      const addressEl = await row.$(SELECTORS.address);
      const cityStateZipEl = await row.$(SELECTORS.cityStateZip);
      const phoneEl = await row.$(SELECTORS.phone);

      const addressText = addressEl ? await addressEl.innerText() : '';
      const cityStateZipText = cityStateZipEl ? await cityStateZipEl.innerText() : '';
      const phoneText = phoneEl ? await phoneEl.innerText() : '';

      // Parse all fields
      const { firstName, middleInitial, lastName } = parseName(name);
      const { address1, address2 } = parseAddress(addressText);
      const { city, state, zip } = parseCityStateZip(cityStateZipText);
      const phone = cleanPhone(phoneText);

      contacts.push({
        firstName,
        middleInitial,
        lastName,
        address1,
        address2,
        city,
        state,
        zip,
        phone,
        email: '', // Will be filled later
        href: href ? new URL(href, page.url()).href : null
      });
    } catch (e) {
      console.log(`      ‚ö† Error parsing row ${i}: ${e.message}`);
    }
  }

  return contacts;
}

/**
 * Check if there's a next page
 */
async function hasNextPage(page) {
  try {
    const nextBtn = await page.$(SELECTORS.nextPage);
    if (!nextBtn) return false;

    // Check if disabled
    const isDisabled = await nextBtn.evaluate(el =>
      el.classList.contains('disabled') ||
      el.hasAttribute('disabled') ||
      el.getAttribute('aria-disabled') === 'true' ||
      el.style.display === 'none'
    );

    return !isDisabled;
  } catch (e) {
    return false;
  }
}

/**
 * Go to next page
 */
async function goToNextPage(page) {
  try {
    const nextBtn = await page.$(SELECTORS.nextPage);
    if (nextBtn) {
      await nextBtn.click();
      await page.waitForTimeout(CONFIG.delayBetweenPages);
      await page.waitForLoadState('domcontentloaded');
      return true;
    }
  } catch (e) {
    console.log(`   ‚ö† Error navigating: ${e.message}`);
  }
  return false;
}

/**
 * Main scraping function
 */
async function scrapeContacts() {
  console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  console.log('       PFAC Pro Contact Scraper (Configurable)');
  console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');

  console.log('Selectors in use:');
  Object.entries(SELECTORS).forEach(([key, val]) => {
    console.log(`   ${key}: ${val}`);
  });
  console.log('');

  const browser = await chromium.launch({
    headless: CONFIG.headless,
    slowMo: CONFIG.slowMo
  });

  const context = await browser.newContext({
    viewport: { width: 1280, height: 900 }
  });

  const page = await context.newPage();

  try {
    console.log(`üìç Navigating to: ${CONFIG.baseUrl}`);
    await page.goto(CONFIG.baseUrl, { waitUntil: 'domcontentloaded', timeout: CONFIG.timeout });

    await waitForResults(page);

    let pageNum = 1;
    let continueProcessing = true;

    while (continueProcessing && pageNum <= CONFIG.maxPages) {
      console.log(`\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`);
      console.log(`  PAGE ${pageNum}`);
      console.log(`‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`);

      // Extract contacts from current page
      const pageContacts = await extractContactsFromPage(page);
      console.log(`   Extracted ${pageContacts.length} contacts`);

      // Process each contact to get email
      for (let i = 0; i < pageContacts.length; i++) {
        const contact = pageContacts[i];
        processedCount++;

        console.log(`   [${processedCount}] ${contact.firstName} ${contact.lastName}`);

        if (contact.href) {
          const currentUrl = page.url();

          // Go to detail page for email
          contact.email = await getEmailFromDetailPage(page, contact.href);

          if (contact.email) {
            console.log(`      ‚úì Email: ${contact.email}`);
          } else {
            console.log(`      ‚úó No email found`);
          }

          // Go back to results
          await page.goto(currentUrl, { waitUntil: 'domcontentloaded', timeout: CONFIG.timeout });
          await page.waitForTimeout(CONFIG.delayBetweenContacts);
        }

        // Remove href before saving
        delete contact.href;
        allContacts.push(contact);

        // Save progress every 10 contacts
        if (allContacts.length % 10 === 0) {
          const outputPath = saveToCSV(allContacts, CONFIG.outputFile);
          console.log(`\n   üíæ Progress saved: ${allContacts.length} contacts -> ${outputPath}\n`);
        }
      }

      // Check for next page
      if (await hasNextPage(page)) {
        console.log(`\n   ‚û°Ô∏è  Going to page ${pageNum + 1}...`);
        const success = await goToNextPage(page);
        if (success) {
          pageNum++;
        } else {
          continueProcessing = false;
        }
      } else {
        console.log('\n   ‚úì No more pages.');
        continueProcessing = false;
      }
    }

    // Final save
    const outputPath = saveToCSV(allContacts, CONFIG.outputFile);

    console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    console.log('                  SCRAPING COMPLETE!');
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    console.log(`\nüìä Total contacts: ${allContacts.length}`);
    console.log(`üìÅ CSV file: ${outputPath}`);
    console.log('\nüí° To import into Google Sheets:');
    console.log('   1. Open Google Sheets');
    console.log('   2. File ‚Üí Import ‚Üí Upload');
    console.log('   3. Select the CSV file');
    console.log('   4. Choose "Replace" or "Insert new sheet"');
    console.log('   5. Click "Import data"');
    console.log('');

  } catch (error) {
    console.error('\n‚ùå Error:', error.message);

    if (allContacts.length > 0) {
      const outputPath = saveToCSV(allContacts, CONFIG.outputFile);
      console.log(`üíæ Saved ${allContacts.length} contacts before error -> ${outputPath}`);
    }
  } finally {
    console.log('\nClosing browser...');
    await browser.close();
  }
}

// Run
scrapeContacts().catch(console.error);
